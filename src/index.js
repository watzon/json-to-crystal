/*
    JSON to Crystal
    Copyright Â© 2018 Christopher Watson

    This script converts a JSON input into a series of Crystal classes with
    JSON mappings defined.
*/

const _ = require('lodash')
require('./string')
require('./array')

const noop = () => {}

class JsonParseError extends Error {}
class UnsupportedTypeError extends Error {}

class CrystalUtil {

  static crystalType (val) {
    if (val === null)
      return 'JSON::Any'

    switch (typeof val) {
      case 'string':
        return 'String'
      case 'number':
        if (val % 1 === 0) {
          // Regular integer
          if (val > -2147483648 && val < 2147483647)
            return 'Int32'
          else
            return 'Int64'
        } else {
          // Float
          return 'Float64'
        }
      case 'boolean':
        return 'Bool'
      case 'object':
        if (_.isArray(val))
          return 'array'
        return 'class'
      default:
        return 'JSON::Any'
    }
  }

  static formatKey (str) {
    if (!str) {
      return ''
    } else if (str.match(/^\d+$/)) {
      // Identifier is a number
      str = 'num' + str
    } else if (str.charAt(0).match(/\d/)) {
      // First character is a number
      let numbers = {
        '0': 'zero_', '1': 'one_', '2': 'two_', '3': 'three_',
        '4': 'four_', '5': 'five_', '6': 'six_', '7': 'seven_',
        '8': 'eight_', '9': 'nine_'
      }
      str = numbers[str.charAt(0)] + str.substr(1)
    }
    return _.snakeCase(str)
  }

}

class CrystalNamedTuple {

  constructor (properties = {}, options = {}) {
    this.properties = properties
    this.options = _.defaultsDeep(options, this._defaultOptions)
  }

  toString () {
    let pairs = Object.keys(this.properties)
      .map(k => [this.options.transformKeys(k), CrystalUtil.crystalType(this.properties[k])])
    let props = pairs.reduce((prev, cur, idx, arr) => {
      let str = cur.join(': ')
      if (idx < pairs.length - 1)
        str += ', '
      return prev + str
    }, '')
    return `NamedTuple(${props})`
  }

  get _defaultOptions () {
    return { transformKeys: CrystalUtil.formatKey }
  }
}

class CrystalArray {

  constructor (arr = [], options = {}) {
    this.rawArr = arr
    this.classes = []
    this.options = _.defaultsDeep(options, this._defaultOptions)
  }

  toString () {
    let types = this.rawArr
      .map(v => CrystalUtil.crystalType(v))
      .map((v, i) => {
        if (v === 'class') {
          const name = 'AryCls' + (new Date()).getTime().toString().slice(8)
          const cls = new CrystalClass(this.rawArr[i], name, this.options)
          this.classes.push(cls)
          return name
        } else if (v === 'array') {
          const ary = new CrystalArray(this.rawArr[i], this.options)
          return ary.toString()
        }
        return v
      })

    let unique = _.uniq(types)
    if (unique.length === 0)
      unique.push("JSON::Any")
    let union = unique.join(" | ")
    return `Array(${union})`
  }

  get _defaultOptions () {
    return {}
  }

}

class CrystalClass {

  constructor (
    properties = {},
    name = 'AutoGenerated',
    options = {}) {
    this.name = this._formatClassName(name)
    this.properties = properties
    this.subclasses = []
    this.options = _.defaultsDeep(options, this._defaultOptions)
    this.classString = ''
  }

  parse () {
    let indentLevel = this.options.baseIndent
    let arr = []

    // Class definition start
    arr.push(this._indent(`class ${this.name}`, indentLevel))

    this._spacing(arr)

    const keys = Object.keys(this.properties)
    if (keys.length > 0) {

      // JSON mapping start
      arr.push(this._indent('JSON.mapping({', ++indentLevel))

      // Increase the indent level for items
      indentLevel++

      // Loop over the keys and add each one to our mapping
      let items = keys
        .filter(_.negate(this.options.ignoreKeys))
        .map((x, i) => {
          let key = this.options.transformKeys.call(this, x)
          let type = CrystalUtil.crystalType(this.properties[x])

          if (type === 'class') {
            if (_.isEmpty(this.properties[x])) {
              type = 'Hash(JSON::Any, JSON::Any)'
            } else {
              const klass = new CrystalClass(this.properties[x], key, _.defaultsDeep({ baseIndent: indentLevel - 1 }, this.options))
              this.subclasses.push(klass)
              type = klass.name
            }
          } else if (type === 'array') {
            const ary = new CrystalArray(this.properties[x], _.defaultsDeep({ baseIndent: indentLevel - 1 }, this.options))
            type = ary.toString()
            this.subclasses = this.subclasses.concat(ary.classes)
          }

          let str = `${key}: `

          if (this.options.explicit && key === x) {
            str += `{ `

            if (key !== x)
              str += `key: "${x}", `

            str += `type: ${type}`

            if (this.options.allNilable || this.options.nilable(x, key))
              str += `, nilable: true }`
            else
              str += ' }'
          } else {
            str += type
            if (this.options.allNilable)
              str += '?'
          }

          if (i < keys.length - 1)
            str += ','

          return this._indent(str, indentLevel)
        })
      arr = arr.concat(items)

      // JSON mapping end
      arr.push(this._indent('})', --indentLevel))

      this._spacing(arr)

      // Make sure all subclasses are unique
      this.subclasses = _.uniq(this.subclasses)

      // Add subclasses into the mix
      arr = arr.concat(this.subclasses.map(sub => sub.toString()))

      // Class definition end
      arr.push(this._indent('end', --indentLevel))

      this._spacing(arr)

      return arr.join('\n')
    }
  }

  toString () {
    if (this.classString)
      return this.classString
    return this.classString = this.parse()
  }

  _indent (str, level = this.options.baseIndent) {
    if (level <= 0)
      return str
    return '  '.repeat(level) + str
  }

  _formatClassName (name) {
    return _.upperFirst(_.camelCase(name))
  }

  _spacing (arr) {
    if (this.options.compact)
      return
    arr.push('')
  }

  get _defaultOptions () {
    return {
      baseIndent: 0,
      ignoreKeys: noop,
      ignoreValues: noop,
      transformKeys: CrystalUtil.formatKey,
      allNilable: false,
      nilable: noop,
      compact: false,
      explicit: false
    }
  }
}

class JsonToCrystal {

  constructor(options = {}) {
    this.options = _.defaultsDeep(options, this._defaultOptions)
  }

  parse(scope) {
    if (_.isString(scope)) {
      try {
        const data = JSON.parse(scope.replace(/\.0/g, '.1'))
        return this.parse(data)
      } catch (e) {
        throw new JsonParseError(e.message)
      }
    } else if (_.isArray(scope)) {
      const arr = new CrystalArray(scope)
      let str = []
      str.push(`alias AutoGenerated = ${arr.toString()}`)
      if (arr.classes.length > 0) {
        if (!this.options.compact)
          str.push('')
        arr.classes.forEach(cls => str.push(cls.toString()))
      }
      return str.join("\n")
    } else if (_.isPlainObject(scope)) {
      const cls = new CrystalClass(scope, this.options.baseClassName, this.options)
      return cls.toString()
    }
    throw new UnsupportedTypeError(`Unsupported data type ${typeof scope}.`)
  }

  get _defaultOptions () {
    return {
      baseClassName: 'AutoGenerated',
      baseIndent: 0,
      ignoreKeys: noop,
      ignoreValues: noop,
      transformKeys: CrystalUtil.formatKey,
      allNilable: false,
      nilable: noop,
      compact: false,
      explicit: false
    }
  }
}

module.exports = {
  JsonParseError,
  UnsupportedTypeError,
  CrystalUtil,
  CrystalArray,
  CrystalClass,
  CrystalNamedTuple,
  JsonToCrystal
}
